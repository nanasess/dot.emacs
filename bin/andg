#! /usr/bin/perl

#####################################################################################
## 空白文字で区切られた検索文字を and検索 するためのコマンドです。
##
##   Usage: andg [-hi] [-e] "PATTERN [PATTERN...]" FILES or DIRECTORIES
##
## ※ 空白がエスケープされているか二つ並んでいる場合は、その空白を一文字の検索文字と
##    みなします。
## see also. http://www49.atwiki.jp/ntemacs/pages/33.html
#####################################################################################

# ■検索用のコマンドを設定する
# ・$grep_command1 には最初に実行するコマンドを、$grep_command2 には二番目以降に
#   フィルターのために実行するコマンドを指定してください
# ・検索のオプション（特に漢字指定箇所）は適宜見直してください
# ・$grep_command1 では、検索したファイル名と行番号が表示されるようにしてください
#   （ファイル名の表示は、lgrep のように複数ファイルの検索でファイル名表示となる
#     コマンドもあるため、実行するコマンドに /dev/null を追加することでも対応して
#     います。）
# ・-i（case insensitive）オプションが使える場合は、そのオプションを指定する位置に
#   %c を“マイナスを付けずに”指定してください。
# ・以下では、lgrep 以外リカーシブ検索が可能な設定としています。（lgrep にはこの
#   オプションがないため。）リカーシブ検索が可能な場合、検索対象に DIRECTORIES が
#   指定可能となります。

# for lgrep
$grep_command1 = "lgrep -n -Os -Ia +i %c -";
$grep_command2 = "lgrep -Os +i %c -";

# for grep
# $grep_command1 = "grep -n -r %c --color=never --";
# $grep_command2 = "grep %c --color=never --";

# for ack
# $grep_command1 = "ack %c --no-group --no-color --";
# $grep_command2 = "ack %c --no-color --";

# for ag
# $grep_command1 = "ag %c --nogroup --nocolor --";
# $grep_command2 = "ag %c --nocolor --";

#####################################################################################

use File::Basename;
use Getopt::Std;

# Usage を表示し、終了する
sub usage_exit {
    print STDERR "Usage: ", basename($0), " [-hi] [-e] \"PATTERN [PATTERN...]\" FILES or DIRECTORIES\n";
    exit(1);
}

# オプションの取得
if (getopts("hie:", \%opts) == null) {
    usage_exit();
}

# オプションの判定
foreach $key (keys %opts) {
    if ($key eq "e") {
        # 検索文字列を設定する
        $pattern = $opts{$key};
    }
    elsif ($key eq "i") {
        # 大文字小文字を区別する
        $grep_command1 =~ s/%c/-i/;
        $grep_command2 =~ s/%c/-i/;
    }
    elsif ($key eq "h") {
        usage_exit();
    }
}

# 検索文字列を変数に格納する 
if (!defined($pattern)) {
    $pattern = $ARGV[0];
    shift(@ARGV);
}

# 引数の残りが1つ以上なければ終了する
if ($#ARGV < 0) {
    usage_exit();
}

# 検索文字列の最後が中途半端な￥サインで終わっていたら終了する
if ($pattern =~ /[^\\]\\$/) {
    usage_exit();
}

# 指定されなかったオプション指定文字を削除する
$grep_command1 =~ s/%.//g;
$grep_command2 =~ s/%.//g;

# 検索文字列の区切り文字から除外する空白文字のパターンを正規表現で指定する
$space_regexp = qr/[\\ ] /;

# エスケープされた空白文字を一旦置き換える
$pattern =~ s/$space_regexp/\0\0/g;

# 検索文字列の前後の空白文字を削除する
$pattern =~ s/^ *(.*?) *$/$1/;

# 検索文字列を空白文字区切りで配列にし、置き換えていたエスケープ空白文字を元に戻す
@patterns = map { s/\0\0/ /g; $_ } split(/ +/, $pattern);

# 検索するファイルの配列を空白区切りの文字列にする
$files = '"' . join('" "', @ARGV) . '"';

# 検索用のコマンドを構成する
$command = "$grep_command1 \"$patterns[0]\" $files /dev/null";
while ($#patterns > 0) {
    shift(@patterns);
    # 二回目以降の検索ではファイル名と行番号の部分をパスして検索する
    $command = "$command | $grep_command2 \"^[^:][^:]*:[^:][^:]*:.*$patterns[0]\"";
}

# 検索コマンドを実行する
system($command);
# print $command; # for debug
